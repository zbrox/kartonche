#!/usr/bin/env bash
#MISE description="Check localization completeness and issues"

set -euo pipefail

# Use IOS_DEVICE if set, otherwise default to iPhone 17 Pro
DEVICE="${IOS_DEVICE:-iPhone 17 Pro}"

# Detect if running in CI environment
IS_CI=false
if [ -n "${CI:-}" ] || [ -n "${GITHUB_ACTIONS:-}" ] || [ -n "${GITLAB_CI:-}" ] || [ -n "${JENKINS_HOME:-}" ] || [ -n "${TEAMCITY_VERSION:-}" ]; then
  IS_CI=true
fi

# Set output style based on environment
if [ "$IS_CI" = true ]; then
  INFO="[INFO]"
  WARN="[WARN]"
  ERROR="[ERROR]"
  SUCCESS="[OK]"
  TRASH="[UNUSED]"
  NEW="[NEW]"
else
  INFO="‚ÑπÔ∏è "
  WARN="‚ö†Ô∏è "
  ERROR="‚ùå"
  SUCCESS="‚úÖ"
  TRASH="üóëÔ∏è "
  NEW="üìù"
fi

CATALOG="kartonche/Resources/Localizable.xcstrings"

echo "${INFO}Checking localization for kartonche..."
echo ""

# Step 1: Build project to generate .stringsdata files
if [ "$IS_CI" = true ]; then
  echo "[INFO] Building project to extract string usage..."
else
  echo "üî® Building project to extract string usage..."
fi

BUILD_LOG=$(mktemp)
if ! xcodebuild clean build \
  -project "$PROJECT" \
  -scheme "$SCHEME" \
  -configuration "$CONFIGURATION" \
  -destination "platform=iOS Simulator,name=$DEVICE" \
  -quiet > "$BUILD_LOG" 2>&1; then
  echo "$ERROR Build failed - cannot check localization"
  echo "$INFO Check build errors with: mise run check"
  rm -f "$BUILD_LOG"
  exit 1
fi
rm -f "$BUILD_LOG"

# Step 2: Find DerivedData and collect .stringsdata files
OBJROOT=$(xcodebuild -project "$PROJECT" -scheme "$SCHEME" -showBuildSettings 2>/dev/null | grep -m 1 "OBJROOT" | sed 's/.*= *//')
STRINGSDATA_DIR="$OBJROOT"

if [ ! -d "$STRINGSDATA_DIR" ]; then
  echo "$ERROR Cannot find DerivedData intermediates directory: $STRINGSDATA_DIR"
  exit 1
fi

# Step 3: Extract string usage from .stringsdata files
USED_STRINGS_TEMP=$(mktemp)
declare -A STRING_LOCATIONS

find "$STRINGSDATA_DIR" -name "*.stringsdata" 2>/dev/null | while read -r file; do
  SOURCE_FILE=$(jq -r '.source' "$file" 2>/dev/null)
  if [ -n "$SOURCE_FILE" ] && [ "$SOURCE_FILE" != "null" ]; then
    FILENAME=$(basename "$SOURCE_FILE")
    jq -r '.tables.Localizable[]? | "\(.key)|\(.location.startingLine)"' "$file" 2>/dev/null | while IFS='|' read -r key line; do
      if [ -n "$key" ]; then
        echo "${key}|${FILENAME}:${line}"
      fi
    done
  fi
done | sort > "$USED_STRINGS_TEMP"

# Build the STRING_LOCATIONS associative array
while IFS='|' read -r key location; do
  if [ -n "$key" ]; then
    if [ -n "${STRING_LOCATIONS[$key]:-}" ]; then
      STRING_LOCATIONS[$key]="${STRING_LOCATIONS[$key]}|${location}"
    else
      STRING_LOCATIONS[$key]="${location}"
    fi
  fi
done < "$USED_STRINGS_TEMP"

# Get unique used strings
USED_STRINGS=$(cut -d'|' -f1 "$USED_STRINGS_TEMP" | sort -u)

# Step 4: Analyze string catalog
if [ ! -f "$CATALOG" ]; then
  echo "$ERROR String catalog not found: $CATALOG"
  exit 1
fi

# Get all strings from catalog
ALL_CATALOG_STRINGS=$(jq -r '.strings | keys[]' "$CATALOG" | sort)
TOTAL_STRINGS=$(echo "$ALL_CATALOG_STRINGS" | wc -l | xargs)

# Extract all languages from the catalog (excluding source language which is typically 'en')
# Languages are found in .strings.<key>.localizations.<lang>
ALL_LANGUAGES=$(jq -r '[.strings[].localizations // {} | keys[]] | unique | .[]' "$CATALOG" 2>/dev/null | sort -u)

# Filter to non-English languages (English is the source, others are translations)
TARGET_LANGUAGES=()
while IFS= read -r lang; do
  if [ -n "$lang" ] && [ "$lang" != "en" ]; then
    TARGET_LANGUAGES+=("$lang")
  fi
done <<< "$ALL_LANGUAGES"

if [ ${#TARGET_LANGUAGES[@]} -eq 0 ]; then
  echo "$WARN No target languages found in catalog"
  echo "$INFO Add translations in Xcode: Project > Info > Localizations"
  exit 0
fi

echo "${INFO}Found ${#TARGET_LANGUAGES[@]} target language(s): ${TARGET_LANGUAGES[*]}"
echo ""

# Find unused strings (in catalog but not in code)
UNUSED_TEMP=$(mktemp)
comm -23 <(echo "$ALL_CATALOG_STRINGS") <(echo "$USED_STRINGS") > "$UNUSED_TEMP"
UNUSED_COUNT=$(wc -l < "$UNUSED_TEMP" | xargs)

# Find strings marked as "do not translate"
NO_TRANSLATE_COUNT=$(jq -r '.strings | to_entries[] | select(.value.shouldTranslate == false) | .key' "$CATALOG" 2>/dev/null | wc -l | xargs)

# Track failures
TOTAL_MISSING=0

# Helper function to get language display name
get_language_name() {
  case "$1" in
    bg) echo "Bulgarian" ;;
    de) echo "German" ;;
    en) echo "English" ;;
    es) echo "Spanish" ;;
    fr) echo "French" ;;
    it) echo "Italian" ;;
    ja) echo "Japanese" ;;
    ko) echo "Korean" ;;
    pl) echo "Polish" ;;
    pt) echo "Portuguese" ;;
    ru) echo "Russian" ;;
    uk) echo "Ukrainian" ;;
    zh) echo "Chinese" ;;
    *) echo "$1" ;;
  esac
}

# Process each target language
for LANG in "${TARGET_LANGUAGES[@]}"; do
  LANG_NAME=$(get_language_name "$LANG")
  
  # Find strings missing translations for this language (exclude shouldTranslate: false)
  MISSING_TEMP=$(mktemp)
  jq -r --arg lang "$LANG" '.strings | to_entries[] | select(.value.localizations[$lang] == null and (.value.shouldTranslate != false)) | .key' "$CATALOG" > "$MISSING_TEMP"
  
  # Find strings needing review for this language
  REVIEW_TEMP=$(mktemp)
  jq -r --arg lang "$LANG" '.strings | to_entries[] | select(.value.localizations[$lang].stringUnit.state == "needs_review") | .key' "$CATALOG" 2>/dev/null > "$REVIEW_TEMP" || true
  
  # Find new strings for this language (exclude shouldTranslate: false)
  NEW_TEMP=$(mktemp)
  jq -r --arg lang "$LANG" '.strings | to_entries[] | select(.value.localizations[$lang].stringUnit.state == "new" and (.value.shouldTranslate != false)) | .key' "$CATALOG" 2>/dev/null > "$NEW_TEMP" || true
  
  # Categorize missing translations
  MISSING_FORMAT=()
  MISSING_CYRILLIC=()
  MISSING_OTHER=()
  
  while IFS= read -r key; do
    if [ -z "$key" ]; then continue; fi
    
    # Check if format string
    if echo "$key" | grep -qE '%[@dlLuUfFeEgGxXoOsSaA]|%[0-9]+\$|\\[ntfrbv]'; then
      MISSING_FORMAT+=("$key")
    # Check if contains Cyrillic (likely Bulgarian source text)
    elif echo "$key" | grep -qE '[–ê-–Ø–∞-—è–Å—ë]'; then
      MISSING_CYRILLIC+=("$key")
    else
      MISSING_OTHER+=("$key")
    fi
  done < "$MISSING_TEMP"
  
  MISSING_COUNT=$((${#MISSING_FORMAT[@]} + ${#MISSING_CYRILLIC[@]} + ${#MISSING_OTHER[@]}))
  REVIEW_COUNT=$(wc -l < "$REVIEW_TEMP" | xargs)
  NEW_COUNT=$(wc -l < "$NEW_TEMP" | xargs)
  
  # Track total missing
  TOTAL_MISSING=$((TOTAL_MISSING + MISSING_COUNT))
  
  # Section header
  echo "‚îÅ‚îÅ‚îÅ $LANG_NAME ($LANG) ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  # Missing translations
  if [ "$MISSING_COUNT" -eq 0 ]; then
    echo "$SUCCESS No missing translations"
  else
    echo "$ERROR Missing translations: $MISSING_COUNT"
    
    # Show other strings (main category)
    if [ ${#MISSING_OTHER[@]} -gt 0 ]; then
      for key in "${MISSING_OTHER[@]}"; do
        echo "   $WARN \"$key\""
        if [ -n "${STRING_LOCATIONS[$key]:-}" ]; then
          IFS='|' read -ra LOCS <<< "${STRING_LOCATIONS[$key]}"
          for loc in "${LOCS[@]}"; do
            echo "      ‚îî‚îÄ $loc"
          done
        fi
      done
    fi
    
    # Show Cyrillic keys
    if [ ${#MISSING_CYRILLIC[@]} -gt 0 ]; then
      for key in "${MISSING_CYRILLIC[@]}"; do
        echo "   $WARN \"$key\" (Cyrillic key)"
        if [ -n "${STRING_LOCATIONS[$key]:-}" ]; then
          IFS='|' read -ra LOCS <<< "${STRING_LOCATIONS[$key]}"
          for loc in "${LOCS[@]}"; do
            echo "      ‚îî‚îÄ $loc"
          done
        fi
      done
    fi
    
    # Show format strings as info
    if [ ${#MISSING_FORMAT[@]} -gt 0 ]; then
      for key in "${MISSING_FORMAT[@]}"; do
        echo "   $INFO \"$key\" (format string)"
      done
    fi
  fi
  
  # Review needed
  if [ "$REVIEW_COUNT" -gt 0 ]; then
    echo ""
    echo "$WARN Needs review: $REVIEW_COUNT"
    while IFS= read -r key; do
      if [ -n "$key" ]; then
        echo "   $WARN \"$key\""
      fi
    done < "$REVIEW_TEMP"
  fi
  
  # New strings
  if [ "$NEW_COUNT" -gt 0 ]; then
    echo ""
    echo "$NEW New strings: $NEW_COUNT"
    while IFS= read -r key; do
      if [ -n "$key" ]; then
        echo "   $NEW \"$key\""
      fi
    done < "$NEW_TEMP"
  fi
  
  echo ""
  
  # Cleanup temp files for this language
  rm -f "$MISSING_TEMP" "$REVIEW_TEMP" "$NEW_TEMP"
done

# Unused strings section (language-agnostic)
echo "‚îÅ‚îÅ‚îÅ Potentially Unused Strings ($UNUSED_COUNT) ‚îÅ‚îÅ‚îÅ"
echo ""

if [ "$UNUSED_COUNT" -eq 0 ]; then
  echo "$SUCCESS No unused strings detected"
else
  COUNT=0
  while IFS= read -r key; do
    if [ -n "$key" ]; then
      echo "$TRASH \"$key\""
      COUNT=$((COUNT + 1))
      if [ "$COUNT" -ge 10 ]; then
        REMAINING=$((UNUSED_COUNT - 10))
        if [ "$REMAINING" -gt 0 ]; then
          echo "$INFO ... and $REMAINING more"
        fi
        break
      fi
    fi
  done < "$UNUSED_TEMP"
  
  echo ""
  if [ "$IS_CI" = true ]; then
    echo "[INFO] Tip: Remove unused strings to keep catalog clean"
  else
    echo "üí° Tip: Remove unused strings to keep catalog clean"
  fi
fi

echo ""

# Summary section
echo "‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ"
echo ""

if [ "$IS_CI" = true ]; then
  echo "[INFO] Total strings in catalog: $TOTAL_STRINGS"
  echo "[INFO] Target languages: ${TARGET_LANGUAGES[*]}"
  echo "[INFO] Do not translate: $NO_TRANSLATE_COUNT"
  echo "[INFO] Unused: $UNUSED_COUNT"
else
  echo "üìä Total strings in catalog: $TOTAL_STRINGS"
  echo "üåç Target languages: ${TARGET_LANGUAGES[*]}"
  echo "$INFO Do not translate: $NO_TRANSLATE_COUNT"
  echo "$TRASH Unused: $UNUSED_COUNT"
fi

echo ""

# Cleanup
rm -f "$USED_STRINGS_TEMP" "$UNUSED_TEMP"

# Exit with appropriate code
if [ "$TOTAL_MISSING" -gt 0 ]; then
  echo "$ERROR Check failed: $TOTAL_MISSING strings missing translations"
  exit 1
else
  echo "$SUCCESS All languages have complete translations!"
  exit 0
fi
